# Домашнее задание 3

> **Цель:** осуществить практическое применение средств синхронизации потоков.  
> **Срок сдачи: отсутствует, неблокирующее домашнее задание**

**Реализовать Thread Pool специального вида**

Задание по вариантам. Вариант выбирается по желанию.

## Вариант 1. Thread Pool with scheduling.

### Требования к реализации

Thread Pool должен выполнять задачи следующих типов:

- common: выполнение функции один раз
- delayed: выполнение функции один раз после некоторой задержки
- periodic: выполнение одной и той же функции через каждый заданный период времени (например, каждую секунду)
- interval: выполнение одной и той же функции с заданным интервалом между выполнениями (например, должна пройти секунда между выполнением задач) 

Требуемое к реализации API класса (с точностью до синтаксиса и кодстайла выбранного языка программирования):

```cs
class ScheduledThreadPool {
    // инициализация
    public ScheduledThreadPool() { }

    // выполнение задачи без условий
    public void SubmitCommon(Action<object?> task, object? arg) { }

    // выполнение задачи после по истечению времени delay
    public void SubmitDelayed(Action<object?> task, object? arg, TimeSpan delay) { }

    // выполнение задачи через каждое period количество времени
    public void SubmitPeriodic(Action<object?> task, object? arg, TimeSpan period) { }
    
    // выполнение задачи через интервал interval
    public void SubmitInterval(Action<object?> task, object? arg, TimeSpan interval) { }
}
```

### Рекомендации по реализации

1. Можно раздавать "роли" различным потокам в пуле потоков (по их назначению), выделять их в группы.
1. Не обязательно должна быть только одна очередь задач.
1. Внимательно смотрите на примитивы, которые используете при реализации - это должны быть именно примитивы. Например, `System.Threading.Timer` сам внутри себя использует Thread Pool и сложную логику с очередями ([исходник реализации](https://github.com/dotnet/runtime/blob/ce99c5658cc8c6ef426f54864d394ba443820840/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs)). Встраивать библиотечный тредпул в самописный тредпул выглядит нелогичным.
1. Подсказкой к решению может быть рассуждение по [этой ссылке](https://stackoverflow.com/questions/12402233/c-timer-class-implementation).
1. Если вам потребуются вспомогательные структуры данных, постарайтесь найти их реализацию в виде библиотек, сэкономить время на их реализации и отладке.

### Требования к проверке

1. Отбрасывать метрику "количество задач в thread pool'е" раз в 1 секунду.
1. Сделать дашборд в графане с отбрасываемой метрикой и метрикой количества потоков (системной).
1. Прогнать следующий тест-кейс:
    - Подождать 5 секунд.
    - Запустить на тредпуле 100 задач с рандомной задержкой от 500 до 1500 милисекунд. Каждая задача должна считать число 10е Фибоначчи "по определению".
    - Подождать 5 секунд.
    - Запустить на тредпуле 10 задач с периодичностью 3 секунды, увеличивающих некоторый глобальный счётчик на единицу.
    - Запустить на тредпуле задачу, которая с интервалом 2 секунды отбрасывает метрику "значение счётчика". Счётчик из предыдущего пункта тест-кейса. На дашборде требуется отображать метрику как временной ряд.
    - Подождать 30 секунд.
1. Рядом с реализацией требуется положить скриншот дашборда графаны во временном интервале исполнения теста.

## Вариант 2. Thread Pool aka fork/join.

### Требования к реализации

Thread pool должен иметь возможность разрешать проблему запуска "рекурсивных" задач. "Рекурсивная" задача - это задача, помещаемая на исполнение в thread pool в ходе исполнения другой задачи.

Требуемое к реализации API класса (с точностью до синтаксиса и кодстайла выбранного языка программирования):

```cs
// обёртка над задачей
class RecursiveTask {
    // инициализация
    public ForkJoinTask(Func<object?, object?> func, object? arg) {}

    // операция, блокирующая выполнение вызывающего потока  
    // до момента выполнения этой задачи и возвращает результат выполнения
    public object? Await() {}
}

// реализация пула потоков
class RecursiveThreadPool {
    // инициализация внутренней структуры
    public RecursiveThreadPool() { }

    // планирование задачи
    public void Submit(RecursiveTask task) { }

    // остановка потоков, чистка других ресурсов
    public void Dispose() { }
}
```

Использование:

```cs
var threadPool = new RecursiveThreadPool();
var task = new RecursiveTask(x => x);
threadPool.Submit(task, 0);
var result = task.Await();

Assert.Equals(0, result); // ok
```

### Рекомендации по реализации

1. У каждого потока имеется идентификатор, выдаваемый ему при создании автоматически (не имя, а именно `id`). Таким образом можно понять, очередная задача создаётся из того же потока, что предыдущие, или уже из другого.
1. Нужно стараться (алгоритмически это не всегда будет возможно) держать общее количество активных потоков равным количеству ядер на машине. Точно нельзя допускать неконтролируемого увеличения количества активных потоков.
1. Здесь может пригодиться примитив `AutoResetEvent` или `ManualResetEvent`.
1. Ниже следует подсказка по возможной реализации. Просьба сначала подумать и почитать интернет, только потом открыть подсказку.

<details>
    <summary>Подсказка по реализации</summary> При вызове Await в данном случае поток блокируется. Причём блокируется именно поток внутри пула потоков. В какой-то момент может возникнуть ситуация, когда все имеющиеся потоки будут заблокированы. Можно реализовать следующий алгоритм: 
    <ol>
    <li>RecursiveTask при вызове метода Join перед уходом в ожидание выполнения увеличивает счётчик "ожидания" в тред пуле на 1</li>
    <li>Увеличение этого счётчика для тредпула означает, что какой-то из его текущих потоков-воркеров заблокировался. Значит нужно создать новый поток-воркер</li>
    <li>После выхода из ожидания в методе Join счётчик можно уменьшить на 1</li>
    <li>Уменьшение этого счётчика для тредпула означает, что какой-то из его текущих потоков-воркеров разблокировался. Значит можно позволить одному из потоков завершить свою работу.</li>
    </ol>
    При этом можно ввести следующую оптимизацию: если какой-то поток-воркер выбирается для останова, пусть он сделает 5-10 SpinWait и в каждый из этих разов проверит, а точно ли ему надо завершаться. Если счётчик за это время успеет увеличиться, то поток может продолжить свою работу дальше. Такая ситуация актуальна, если пользовательский код в цикле попробует сделать Join для большого количества задач. Без этой оптимизации на каждый такой Join будет пересоздаваться поток, что чересчур дорого.
</details>

<p></p>

### Требования к проверке

1. Отбрасывать метрику "количество задач в thread pool'е" раз в 1 секунду. Можно использовать библиотечный Timer.
1. Сделать дашборд в графане с отбрасываемой метрикой и метрикой количества потоков (системной).
1. Прогнать следующий тест-кейс:
    - Создать набор из случайно сгенерированных матриц размера $`m \times m`$. В наборе должно быть $`N`$ матриц.
    - Создать тредпул. Для всех вычислений требуется использовать только один, этот объект тредпула.
    - Для каждой матрицы параллельно с использованием тред пула рассчитать среднее значение элементов и дисперсию. Расчёты среднего значения и дисперсии должны производиться параллельно с использованием тредпула. Результаты всех параллельных вычислений должны возвращаться как возвращаемое значение метода Join.
1. Рядом с реализацией требуется положить скриншот дашборда графаны во временном интервале исполнения теста. Значения параметров $`N`$ и $`m`$ подобрать так, чтобы время выполнения тест-кейса было не меньше 20 секунд. Рекомендуемый порядок величин: $`N=10`$, $`m=1000`$.
